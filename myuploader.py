import time
import serial
import struct

'''
Data format is:
1. 1 byte: payload length (not counting chksum)
2. payload (first byte is some kind of identifier
3. 1 byte: chksum(payload)
'''
# Offsets
code_offset = 0x00000001
data_offset = 0x00001000
sign_offset = 0x00002000
# Sizes
code_size   = 0x000003C8
data_size   = 0x00000344
sign_size   = 0x00000040
# Codes from the prog.img binary
hcode="\x63\x6F\x64\x65" + "\x40\x00\x00\x00" + struct.pack('<I', code_offset) + struct.pack('<I', code_size)
hdata="\x64\x61\x74\x61" + "\x08\x04\x00\x00" + struct.pack('<I', data_offset) + struct.pack('<I', data_size)
hsign="\x73\x69\x67\x6E" + "\x4C\x07\x00\x00" + struct.pack('<I', sign_offset) + struct.pack('<I', sign_size)
def chksum( code ):
	eax = 0;
	for c in code:
		edx = ord(c)
		edx <<= 8
		eax ^= edx
		for x in range(0, 8):
			if eax & 0x8000:
				eax ^= 0x8380
			eax *= 2
	eax >>= 8
	return chr(eax)

def sendSerial( payload ):
	data = chr(len(payload)) + payload + chksum(payload)
	ser.write(data)
	# print payload

# ser = serial.Serial(port='COM4') # for Windows
# ser = serial.Serial(port='/dev/serial/by-id/usb-Arduino_LLC_Arduino_Due-if00') # for Linux
ser = serial.Serial(port='/dev/tty.usbmodem1a151') # for Mac

print "Hi: ",
sendSerial("\x00")
print ser.read(4) # Wait for ACK

# CODE HEADER
print "sending code header: ",
sendSerial("\x03" + hcode)
print ser.read(4) # Wait for ACK

# DATA HEADER
print "sending data header: ",
sendSerial("\x03" + hdata)
print ser.read(4) # Wait for ACK

# SIGN HEADER
print "sending sign header: ",
sendSerial("\x03" + hsign)
print ser.read(4) # Wait for ACK

## Open file and send contents
f = open('prog.img', 'r')

# Code
f.seek(0x40)
for i in xrange(code_offset, code_offset+code_size, 0x80):
	if(((code_offset+code_size)-i) >= 0x80):
		sendSerial("\x01" + struct.pack('<I', i) + f.read(0x80))
	else:
		sendSerial("\x01" + struct.pack('<I', i) + f.read((code_offset+code_size)-i))
	print hex(i) + " : ",
	print ser.read(4)

# Data
for i in xrange(data_offset, data_offset+data_size, 0x80):
	if(((data_offset+data_size)-i) >= 0x80):
		sendSerial("\x01" + struct.pack('<I', i) + f.read(0x80))
	else:
		sendSerial("\x01" + struct.pack('<I', i) + f.read((data_offset+data_size)-i))
	print hex(i) + " : ",
	print ser.read(4)

# Sign
for i in xrange(sign_offset, sign_offset+sign_size, 0x80):
	if(((sign_offset+sign_size)-i) >= 0x80):
		sendSerial("\x01" + struct.pack('<I', i) + f.read(0x80))
	else:
		sendSerial("\x01" + struct.pack('<I', i) + f.read((sign_offset+sign_size)-i))
	print hex(i) + " : ",
	print ser.read(4)

# End
print "Bye: ",
sendSerial("\x02")
print ser.read(4) # Wait for ACK

# Response
print ser.read(0x248)
ser.close()




exit()
